(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{1311:function(t,a,s){"use strict";s.r(a);var l=s(17),i=Object(l.a)({},(function(){var t=this,a=t.$createElement,l=t._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"执行上下文的理解"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文的理解"}},[t._v("#")]),t._v(" 执行上下文的理解")]),t._v(" "),l("ul",[l("li",[t._v("执行上下文分为 全局执行上下文 和 函数执行上下文")]),t._v(" "),l("li",[t._v("执行上下文是一个抽象的概念，代表了当前代码的执行环境/作用域")]),t._v(" "),l("li",[t._v("执行上下文包括了 变量对象，作用域链，this的指向")])]),t._v(" "),l("h2",{attrs:{id:"代码执行流程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#代码执行流程"}},[t._v("#")]),t._v(" 代码执行流程")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("js引擎在js代码正式执行之前会先创建一个执行环境(可以理解为开发商要盖房子，那么得先搞来一块地)")])]),t._v(" "),l("li",[l("p",[t._v("进入该环境以后创建一个变量对象(就是浏览器中的Global对象，类似于先打地基)，该对象用于收集当前环境下的 变量，函数，函数的参数，this的指向")])]),t._v(" "),l("li",[l("p",[t._v("那么是怎么收集的呢？其实就是去找使用了关键字 var 和 function 定义的变量，然后收集起来（其实就是变量提升）,如下代码：我们会发现变量 a1 a2 a3 都被收集起来了，而a4没有被收集起来\n"),l("img",{attrs:{src:s(886),alt:""}})])]),t._v(" "),l("li",[l("p",[t._v("确认this的指向，在浏览器中this指向window，并且该window对象又恰好是浏览器的 Global")])]),t._v(" "),l("li",[l("p",[t._v("创建作用域链")])])]),t._v(" "),l("h2",{attrs:{id:"区分全局执行上下文和函数执行上下文"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#区分全局执行上下文和函数执行上下文"}},[t._v("#")]),t._v(" 区分全局执行上下文和函数执行上下文")]),t._v(" "),l("p",[l("img",{attrs:{src:s(887),alt:""}})]),t._v(" "),l("ul",[l("li",[t._v("从上图中，可显易见会有全局执行上下文，即浏览器的Global对象")]),t._v(" "),l("li",[t._v("当执行foo函数的时候，也会创建一个函数执行上下文，进入该函数执上下文后也会同样创建一个变量对象，对应浏览器中的Local对象，该对象也会收集当前环境下的 变量，函数，函数的参数，this的指向，因此收集了变量y，变量c，this的指向。")]),t._v(" "),l("li",[t._v("在切换浏览器的 【Call Stack】时，Local也会跟着改变")])])])}),[],!1,null,null,null);a.default=i.exports},886:function(t,a,s){t.exports=s.p+"assets/img/1.0d35eb11.png"},887:function(t,a,s){t.exports=s.p+"assets/img/2.e6c9169d.png"}}]);