(window.webpackJsonp=window.webpackJsonp||[]).push([[433],{1320:function(e,r,s){"use strict";s.r(r);var t=s(17),i=Object(t.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"为啥出现promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为啥出现promise"}},[e._v("#")]),e._v(" 为啥出现promise")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("补充："),s("a",{attrs:{href:"https://promisesaplus.cn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("promise规范"),s("OutboundLink")],1)])]),e._v(" "),s("li",[s("p",[e._v("1.promise解决多个异步请求并发，能将多个异步请求合并在一起，同步最终的结果，使用promise.all")])]),e._v(" "),s("li",[s("p",[e._v("2.promise解决 回调地狱问题/链式异步请求问题 ,使用promise的链式调用可以解决")])]),e._v(" "),s("li",[s("p",[e._v("3.promise缺陷：还是基于回调的")])])]),e._v(" "),s("h2",{attrs:{id:"promise的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise的特点"}},[e._v("#")]),e._v(" promise的特点")]),e._v(" "),s("ul",[s("li",[e._v("1.promise的状态：成功态(resolve) 失败态(reject) 等待态/既不成功也不失败(pedding)")]),e._v(" "),s("li",[e._v("2.用户自己决定失败的原因和成功的原因，成功和失败也是用户定义的")]),e._v(" "),s("li",[e._v("3.promise默认执行器(excutor)立即执行")]),e._v(" "),s("li",[e._v("4.promise的实例都拥有一个then方法，其实一个参数是成功的回调，另一个参数是失败的回调")]),e._v(" "),s("li",[e._v("5.如果失败了，也会调用失败的回调")]),e._v(" "),s("li",[e._v("6.如果promise一旦成功就不能失败，一旦失败就不能成功")])])])}),[],!1,null,null,null);r.default=i.exports}}]);